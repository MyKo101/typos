Magnet_p  = Magnet_Test$p.value,
Time_p    = Time_Test$p.value,
Overall_p = Overall_Test$p.value,
Magnet_W  = Magnet_Test$statistic,
Time_w    = Time_Test$statistic,
Overall_W = Overall_Test$statistic,
)
New_Results
#Collate the new results
New_Results <- tibble(
Magnet_W  = Magnet_Test$statistic,
Time_w    = Time_Test$statistic,
Overall_W = Overall_Test$statistic,
Magnet_p  = Magnet_Test$p.value,
Time_p    = Time_Test$p.value,
Overall_p = Overall_Test$p.value
)
New_Results
#Create an empty data set (ready to add results)
p_values <- NULL
for(i in 1:1000)# Run it 1000 times
{
cat(i,"  ") #keep track of number of runs
#Run the tests:
suppressWarnings({
Magnet_Test  <- watson.wheeler.test(Angle ~ Magnet       , data=Model_Data)
Time_Test    <- watson.wheeler.test(Angle ~          Time, data=Model_Data)
Overall_Test <- watson.wheeler.test(Angle ~ Magnet + Time, data=Model_Data)
})
#Collate the new results
New_Results <- tibble(
Magnet_W  = Magnet_Test$statistic,
Time_w    = Time_Test$statistic,
Overall_W = Overall_Test$statistic,
Magnet_p  = Magnet_Test$p.value,
Time_p    = Time_Test$p.value,
Overall_p = Overall_Test$p.value
)
#Add them to the previous loops
p_values <- bind_rows(p_values,
New_Results)
}
# Whats the average p-value for each model?
summarise_all(p_values,mean)
# Whats the maximum p-value for each model?
summarise_all(p_value,max)
### Interpretation:
## Time is non-significant, Magnets is significant and the overall is also significant
## This would be because Magnets is significant
# Whats the average p-value for each model?
summarise_all(Results,mean)
Results <- NULL
for(i in 1:1000)# Run it 1000 times
{
cat(i,"  ") #keep track of number of runs
#Run the tests:
suppressWarnings({
Magnet_Test  <- watson.wheeler.test(Angle ~ Magnet       , data=Model_Data)
Time_Test    <- watson.wheeler.test(Angle ~          Time, data=Model_Data)
Overall_Test <- watson.wheeler.test(Angle ~ Magnet + Time, data=Model_Data)
})
#Collate the new results
New_Results <- tibble(
Magnet_W  = Magnet_Test$statistic,
Time_w    = Time_Test$statistic,
Overall_W = Overall_Test$statistic,
Magnet_p  = Magnet_Test$p.value,
Time_p    = Time_Test$p.value,
Overall_p = Overall_Test$p.value
)
#Add them to the previous loops
Results <- bind_rows(Results,
New_Results)
}
# Whats the average p-value for each model?
summarise_all(Results,mean)
# Whats the maximum p-value for each model?
summarise_all(Results,max)
summarise_all(Results,mean)
summarise_all(Results,max)
bind_rows(
summarise_all(Results,mean),
summarise_all(Results,max)
)
bind_rows(
mean = summarise_all(Results,mean),
max = summarise_all(Results,max)
)
Results
summarise_all(Results,mean)
{
summarise_all(Results,mean)
summarise_all(Results,max)
}
# Whats the average results for each model?
summarise_all(Results,mean)
watson.wheeler.test(Angle ~ Magnet       , data=Model_Data)
names(watson.wheeler.test(Angle ~ Magnet       , data=Model_Data))
broom(watson.wheeler.test(Angle ~ Magnet       , data=Model_Data))
?broom
tidy(watson.wheeler.test(Angle ~ Magnet       , data=Model_Data))
library(broom)
tidy(watson.wheeler.test(Angle ~ Magnet       , data=Model_Data)
)
tidy(watson.wheeler.test(Angle ~ Magnet       , data=Model_Data))
#Run the tests:
suppressWarnings(
bind_rows(
tidy(
watson.wheeler.test(Angle ~ Magnet       , data=Model_Data)
),
tidy(
watson.wheeler.test(Angle ~          Time, data=Model_Data)
),
tidy(
watson.wheeler.test(Angle ~ Magnet + Time, data=Model_Data)
)
)
}) %>%
mutate(Test = c("Magnet","Time","Overall"))
#Run the tests:
suppressWarnings(
bind_rows(
tidy(
watson.wheeler.test(Angle ~ Magnet       , data=Model_Data)
),
tidy(
watson.wheeler.test(Angle ~          Time, data=Model_Data)
),
tidy(
watson.wheeler.test(Angle ~ Magnet + Time, data=Model_Data)
)
)
) %>%
mutate(Test = c("Magnet","Time","Overall"))
?tidyverse
library(broom)
# Whats the average results for each model?
Results %>%
group_by(Test) %>%
summarise_all(mean)
#Add them to the previous loops
Results <- bind_rows(Results,
New_Results)
Results <- NULL
for(i in 1:1000)# Run it 1000 times
{
cat(i,"  ") #keep track of number of runs
#Run the tests:
New_Results <- suppressWarnings(
bind_rows(
tidy(
watson.wheeler.test(Angle ~ Magnet       , data=Model_Data)
),
tidy(
watson.wheeler.test(Angle ~          Time, data=Model_Data)
),
tidy(
watson.wheeler.test(Angle ~ Magnet + Time, data=Model_Data)
)
)
) %>%
mutate(Test = c("Magnet","Time","Overall"))
#Add them to the previous loops
Results <- bind_rows(Results,
New_Results)
}
# Whats the average results for each model?
Results %>%
group_by(Test) %>%
summarise_all(mean)
Results
# Whats the average results for each model?
Results %>%
group_by(Test) %>%
summarise_at(is.numeric,mean)
# Whats the average results for each model?
Results %>%
group_by(Test) %>%
summarise_if(is.numeric,mean)
#Get the averages for each of the models
# summarise_if() will pick out just the numeric variables
Results %>%
group_by(Test) %>%
summarise_if(is.numeric,mean)
?export
document()
devtools::document()
library(devtools)
rm(ls=list())
rm(list=ls())
.package_str <- "" else
.clear_exported <- function()
{
.clear.file <- c("\\name{Exported-typos}",
"\\alias{Exported-typos}",
"\\title{List of currently exported typos}",
"\\description{",
"List of currently exported typos",
"}",
"\\details{",
"Exported typos:",
"\\itemize{",
"}",
"}",
"")
writeLines(.clear.file,"man/Exported-typos.Rd")
writeLines("","R/Exported-typos.R")
}
.typo_doc <- function(.incorrect,.correct,.package=base,back.tick=F)
{
requireNamespace(rlang,quietly=T)
.incorrect_str <- rlang::as_name(rlang::enquo(.incorrect))
.correct_str <- rlang::as_name(rlang::enquo(.correct))
.package_str <- rlang::as_name(rlang::enquo(.package))
if(.package_str == "base")
.package_str <- "" else
.package_str <- paste0(",",.package_str)
.alias <- paste0("\\alias{",.incorrect_str,"}",sep="")
if(back.tick)
{
.incorrect_str <- paste0("`",.incorrect_str,"`")
.correct_str <- paste0("`",.correct_str,"`")
}
.typo_code <- paste0(
.incorrect_str,
" <- .typo(",
.correct_str,
.package_str,
")"
)
.item <- paste0("\\item \\code{",.typo_code,"}")
.export_Rd <- readLines("man/Exported-typos.Rd")
.alias.line <- grep("\\alias{",.export_Rd,fixed=T)
.export_Rd <- append(.export_Rd,
.alias,
after=tail(.alias.line,1))
.export_Rd <- append(.export_Rd,
.item,
after=length(.export_Rd)-3)
writeLines(.export_Rd,"man/Exported-typos.Rd")
.export_R <- readLines("R/Exported-typos.R")
.export_R <- append(.export_R,
c("#' @export",
.typo_code,
""))
writeLines(.export_R,"R/Exported-typos.R")
return(c(.incorrect_str,.correct_str))
}
.typo_test <- function() 2
.clear_exported()
.typo_doc(nameS,names)
.typo_doc(`nameS<-`,`names<-`,back.tick=T)
.typo_doc(typoef,typeof)
.typo_doc(geom_warp,geom_wrap,ggplot2)
.typo_doc(fitler,filter,dplyr)
devtools::document()
knitr::knit("README.Rmd")
devtools::load_all()
help("Exported-typos")
library(devtools)
.clear_exported()
.typo_doc(nameS,names)
.typo_doc(`nameS<-`,`names<-`,back.tick=T)
.typo_doc(typoef,typeof)
.typo_doc(geom_warp,geom_wrap,ggplot2)
.typo_doc(fitler,filter,dplyr)
devtools::document()
knitr::knit("README.Rmd")
devtools::load_all()
help("Exported-typos")
library(rlang)
library(rlang)
library(devtools)
library(roxygen2)
.clear_exported()
.typo_doc(nameS,names)
.typo_doc(`nameS<-`,`names<-`,back.tick=T)
.typo_doc(typoef,typeof)
.typo_doc(geom_warp,geom_wrap,ggplot2)
.typo_doc(fitler,filter,dplyr)
devtools::document()
knitr::knit("README.Rmd")
devtools::load_all()
help("Exported-typos")
getwd()
setwd("C:/Users/mbrxsmbc/Documents/R/My Packages/typos")
getwd()
library(rlang)
library(devtools)
library(roxygen2)
.clear_exported()
.typo_doc(nameS,names)
.typo_doc(`nameS<-`,`names<-`,back.tick=T)
.typo_doc(typoef,typeof)
.typo_doc(geom_warp,geom_wrap,ggplot2)
.typo_doc(fitler,filter,dplyr)
devtools::document()
knitr::knit("README.Rmd")
devtools::load_all()
help("Exported-typos")
library(rlang)
library(devtools)
library(roxygen2)
.clear_exported()
.typo_doc(nameS,names)
?requireNamespace
#' @name typo-functions
#'
#' @title
#' Defining typos
#'
#' @description
#' Function used to create a typo and alert the user
#'
#' @param .correct
#' The correctly spelled function for which the wrapper is being defined
#'
#' @param .package
#' The name of the package containing the correct function
#'
#' @param .typo_function
#' Function to be used as an alert
#'
#' @return
#' Wrapper function to call the correctly spelled function
#'
#' @details
#' The `.typo()` function is used to define a typo within the context
#' of the `typo` package. Without `typo`, mistakenly typed functions
#' will cause an Error and not be evaluated; however with `typo`,
#' the function *is* evaluated and a Warning is thrown.
#'
#' @examples
#' nameS <- .typo(names)
#'
#' @export
#'
.typo <- function(.correct,.package=base,.typo_function=.typo_alert)
{
requireNamespace("rlang",quietly=T)
.pkg_str <- rlang::as_name(rlang::enquo(.package))
.correct_str <- rlang::as_name(rlang::enquo(.correct))
.alert_str <- rlang::as_name(rlang::enquo(.typo_function))
.pkg_func <- paste0(.pkg_str,"::",.correct_str)
.f <- paste0("function(...)\n",
"{\n",
"\trequireNamespace(\"",.pkg_str,"\",quietly=T)\n",
"\t.call <- deparse(sys.call())\n",
"\t",.alert_str,"(\"",.correct_str,"\",.call)\n",
"\t",.pkg_func,"(...)\n",
"}",collapse="")
return(eval(parse(text=.f)))
}
#' @rdname typo-functions
#'
#' @param .call
#' The incorrectly spelled call made by the user
#'
#' @examples
#' .typo_alert("names","nameS(iris)")
#'
#' @export
#'
.typo_alert <- function(.correct,.call)
{
.warn <- paste0("Typo of \"",.correct,"()\" detected in \"",.call,"\"")
warning(.warn,call.=F)
}
.clear_exported <- function()
{
.clear.file <- c("\\name{Exported-typos}",
"\\alias{Exported-typos}",
"\\title{List of currently exported typos}",
"\\description{",
"List of currently exported typos",
"}",
"\\details{",
"Exported typos:",
"\\itemize{",
"}",
"}",
"")
writeLines(.clear.file,"man/Exported-typos.Rd")
writeLines("","R/Exported-typos.R")
}
.typo_doc <- function(.incorrect,.correct,.package=base,back.tick=F)
{
requireNamespace("rlang",quietly=T)
.incorrect_str <- rlang::as_name(rlang::enquo(.incorrect))
.correct_str <- rlang::as_name(rlang::enquo(.correct))
.package_str <- rlang::as_name(rlang::enquo(.package))
if(.package_str == "base")
.package_str <- "" else
.package_str <- paste0(",",.package_str)
.alias <- paste0("\\alias{",.incorrect_str,"}",sep="")
if(back.tick)
{
.incorrect_str <- paste0("`",.incorrect_str,"`")
.correct_str <- paste0("`",.correct_str,"`")
}
.typo_code <- paste0(
.incorrect_str,
" <- .typo(",
.correct_str,
.package_str,
")"
)
.item <- paste0("\\item \\code{",.typo_code,"}")
.export_Rd <- readLines("man/Exported-typos.Rd")
.alias.line <- grep("\\alias{",.export_Rd,fixed=T)
.export_Rd <- append(.export_Rd,
.alias,
after=tail(.alias.line,1))
.export_Rd <- append(.export_Rd,
.item,
after=length(.export_Rd)-3)
writeLines(.export_Rd,"man/Exported-typos.Rd")
.export_R <- readLines("R/Exported-typos.R")
.export_R <- append(.export_R,
c("#' @export",
.typo_code,
""))
writeLines(.export_R,"R/Exported-typos.R")
return(c(.incorrect_str,.correct_str))
}
.typo_test <- function() 2
library(devtools)
library(roxygen2)
.clear_exported()
.typo_doc(nameS,names)
.typo_doc(`nameS<-`,`names<-`,back.tick=T)
.typo_doc(typoef,typeof)
.typo_doc(geom_warp,geom_wrap,ggplot2)
.typo_doc(fitler,filter,dplyr)
devtools::document()
knitr::knit("README.Rmd")
devtools::load_all()
help("Exported-typos")
library(rlang)
library(devtools)
library(roxygen2)
.clear_exported()
.typo_doc(nameS,names)
#.typo_doc(`nameS<-`,`names<-`,back.tick=T)
.typo_doc(typoef,typeof)
.typo_doc(geom_warp,geom_wrap,ggplot2)
.typo_doc(fitler,filter,dplyr)
devtools::document()
knitr::knit("README.Rmd")
devtools::load_all()
help("Exported-typos")
?typos
.export_Rd <- append(.export_Rd,
.item,
after=length(.export_Rd)-3)
2+2
load_all()
.typo
?.typo
.typo("hello")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
My_error <- function(a,b) warning("OH NO! A TYPO!",call.=F)
nms <- .typo(names,.typo_function = My_error)
nms(iris)
document()
document()
load_all()
My_Error <- fuction(a,b) warning("Oh No! A Typo!")
My_Error <- function(a,b) warning("Oh No! A Typo!")
nms <- .typo(names,.typo_function=My_error)
nms(iris)
.typo_alert <- function(a,b) warning("Look at me. I am the typo alert now")
nameS(iris)
library(rlang)
library(devtools)
library(roxygen2)
.clear_exported()
.typo_doc(nameS,names)
.typo_doc(`nameS<-`,`names<-`,back.tick=T)
.typo_doc(typoef,typeof)
.typo_doc(geom_warp,geom_wrap,ggplot2)
.typo_doc(fitler,filter,dplyr)
devtools::document()
knitr::knit("README.Rmd")
devtools::load_all()
help("Exported-typos")
?.typo
?typos
?dplyr
libray(dplyr)
library(dplyr)
?dplyr
library(rlang)
library(devtools)
library(roxygen2)
.clear_exported()
.typo_doc(nameS,names)
.typo_doc(`nameS<-`,`names<-`,back.tick=T)
.typo_doc(typoef,typeof)
.typo_doc(geom_warp,geom_wrap,ggplot2)
.typo_doc(fitler,filter,dplyr)
devtools::document()
knitr::knit("README.Rmd")
devtools::load_all()
help("Exported-typos")
?.typo_alert
